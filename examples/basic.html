---
layout: default
title: Basic Example
---

<section id="docs">
    <div class="container">
		<h1>Hello World</h1>
		<p>Do some super basic parsing. In this example we'll parse things of the form:</p>
			<pre><code>S -> b C d.
C -> c C | [epsilon].</code></pre>

			<br />
		This should match strings of the form "bcccccccccd" with any number of "c"'s in a row (or none).
		<hr />
		<!-- Creating a parser desctiption -->
		<h3>Creating a parser description</h3>
		<p>The first step to creating any great parser is defining the underlying grammar. In Js-parse we use a simple javascript object:</p>
		<code>
			<pre>var parserDescription = {
	"symbols":{
		"b": { "terminal":true, "match":"b" },
		"c": { "terminal":true, "match":"c" },
		"d": { "terminal":true, "match":"d" }
	},
	"productions":{
		"S":[
			[ "b", "C", "d" ]
		],
		"C":[
			[ "c", "C" ],
			[  ]
		]
	},
	"startSymbols": [ "S" ]
};</pre>
		</code>

		<br />
		Theres quite a bit to disect there, but comparing against the original BNF form of the grammar, the correspodnance should be pretty clear.
		<br />
		There are three major components here:
		<br /><br />
		<ol>
			<li><strong>symbols:</strong> This defines all of the essential symbols the parser should expect to encounter. Note that non-terminal symbols do not need to be included here but they can be.</li>
			<li><strong>productions:</strong> This is where the core of the grammar is described, each key in the productions object corresponds to a non-terminal symbol. Each array contained in the value represents a production for that symbol. Other symbols are represented by strings and can represent terminals or non-terminals. Also note, epsilon is represented by an empty array.</li>
			<li><strong>startSymbols:</strong> This ones pretty self-explanatory. Provide an array of potential starting symbols, the grammar will only be accepted if the entire input can be fit into one of these start symbols.</li>
		</ol>

		<hr />

		<!-- Creating the parser -->
		<h3>Creating the parser</h3>
		<p>In this step we create a parser out of the parser description object we created above.</p>
		
		Be sure to have included the parser object definitions using something like <code>var Parser = require("../../lib/index").Parser.LRParser;</code>.

		<br /><br />
		Create the parser:
		<code>
			<pre>// Create the parser
var parser = Parser.CreateWithLexer(parserDescription);</pre>
		</code>

		<br />
		Next we want to do is define some handlers so we can find out whats going on while we're parsing and be alerted if there are any errors.

		<code>
			<pre>// Bind some event handlers
parser.on("accept", function(token_stack){
	console.log("Parser Accept:", require('util').inspect(token_stack, true, 1000));
});

parser.on("error", function(error){
	console.log("Parse Error: ", error.message);
	throw error.message;
});</pre>
		</code>

		<hr />

		<!-- do some parsing! -->
		<h3>Do some parsing!</h3>
		<p>Pass an input string to the parser, tell it you've reached the end of the stream and see the magic happen.</p>
		We want to send some input to the parser but also let it know that we've reached the end of the string. Once it is told the end of the string
		was reached it will decide whether or not to accept the entire input according to the grammar.

		<code>
			<pre>// Begin processing the input
var input = "bccccccd";
parser.append(input);
parser.end();</pre>
		</code>

		If all went according to plan you should see some output like this:
		<pre>Parser Accept: [ { type: 'b', value: 'b' },
  { head: 'S',
    body: 
     [ { type: 'c', value: 'c' },
       { head: 'C',
         body: 
          [ { type: 'c', value: 'c' },
            { head: 'C',
              body: 
               [ { type: 'c', value: 'c' },
                 { head: 'C',
                   body: 
                    [ { type: 'c', value: 'c' },
                      { head: 'C',
                        body: 
                         [ { type: 'c', value: 'c' },
                           { head: 'C',
                             body: 
                              [ { type: 'c', value: 'c' },
                                { head: 'C', body: [ [length]: 0 ] },
                                [length]: 2 ] },
                           [length]: 2 ] },
                      [length]: 2 ] },
                 [length]: 2 ] },
            [length]: 2 ] },
       { type: 'd', value: 'd' },
       [length]: 3 ] },
  [length]: 2 ]</pre>

  		Its far from the most beautiful output we could ask for. If you look closely though, you can see the expected structure represented here. 

  		<!-- String that doesnt match. -->
  		<br /><br />
  		Now lets look quickly at a string which does not conform to our grammar, say <code>bcde</code>:

  		<code>
  			<pre>Unrecognized characters at end of stream: 'e'</pre>
  		</code>

  		You can see that an exception was thrown upon calling <code>parser.end()</code> because additional characters were detected at the end of the string
  		which did not conform to the grammar.

  		<br /><br />
  		That's all you really need to get going, keep reading for some more advanced usage tips to clean up the output a little bit.

  		<hr />
  		
  		<!-- Using mergeRecursive -->
  		<h3>Advanced Tip: Using <code>mergeRecursive</code> to clean up the output.</h3>
  		<p>Sometimes theres no need to create such a deeply nested structure like <code>{"C": {"C": {"C": ... }}}</code>. For this purpose, <code>mergeRecursive</code> was born.</p>

  		Alter the <strong>symbols</strong> portion of our parser description to include the line: <code>"C": { "terminal":false, "mergeRecursive":true }</code>. 
  		<br /><br />
  		Now run the script with <code>bccccccd</code> again and you should see a slightly different output:

  		<code>
  			<pre>Parser Accept: [ { type: 'b', value: 'b' },
  { head: 'S',
    body: 
     [ { type: 'c', value: 'c' },
       { head: 'C',
         body: 
          [ { type: 'c', value: 'c' },
            { type: 'c', value: 'c' },
            { type: 'c', value: 'c' },
            { type: 'c', value: 'c' },
            { type: 'c', value: 'c' },
            [length]: 5 ] },
       { type: 'd', value: 'd' },
       [length]: 3 ] },
  [length]: 2 ]</pre>
  		</code>

  		As you can see, all of those nested C productions have been merged into one instance of a C production and the value being and array of all the values that existed under a chain of nested C type productions.
  		<br /><br />

  		<strong>Note: </strong><code>mergeRecursive</code> will only merge elements if the parent and child are of the same type.

  		<!-- Using mergeRecursive -->
  		<h3>Advanced Tip: Using <code>mergeIntoParent</code> to clean up the output in a different way.</h3>
  		<p>
  			<code>mergeIntoParent</code> is used when the production is important to the parsing process, but not of any semantic relevance. 
  			It causes the production of that symbol to be merged directly into the parent instead of appearing as a child of the given production
  		</p>

  		If we changed the <code>C</code> line in our <strong>symbols</strong> object to <code>"C": { "terminal":false, "mergeIntoParent":true }</code> and ran our script again, we see different output:

  		<code>
  			<pre>[ { type: 'b', value: 'b' },
  { head: 'S',
    body: 
     [ { type: 'c', value: 'c' },
       { type: 'c', value: 'c' },
       { type: 'c', value: 'c' },
       { type: 'c', value: 'c' },
       { type: 'c', value: 'c' },
       { type: 'c', value: 'c' },
       { type: 'd', value: 'd' },
       [length]: 7 ] },
  [length]: 2 ]
</pre>
  		</code>

  		This happens because each time a "c" is encountered it is added to the "S" production rather than creating a new "C" and adding it to that.
	</div>
</section>